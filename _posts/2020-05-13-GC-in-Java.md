# GC 回收机制与分代回收策略

垃圾回收（Garbage Collection，简写为 GC）可能是虚拟机众多知识点中最为大众所熟知的一个了，也是Java开发者最关注的一块知识点。Java 语言开发者比 C 语言开发者幸福的地方就在于，我们不需要手动释放对象的内存，JVM 中的垃圾回收器（Garbage Collector）会为我们自动回收。但是这种幸福是有代价的：一旦这种自动化机制出错，我们又不得不去深入理解 GC 回收机制，甚至需要对这些“自动化”的技术实施必要的监控和调节。

 Java 内存运行时区域的各个部分中，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，这几个区域内不需要过多考虑回收的问题。

 而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。

## 1 什么是垃圾

所谓垃圾就是内存中已经没有用的对象。 既然是”垃圾回收"，那就必须知道哪些对象是垃圾。Java 虚拟机中使用一种叫作**可达性分析**的算法来决定对象是否可以被回收。

### 1.1 可达性分析

可达性分析算法是从离散数学中的图论引入的，JVM 把内存中所有的对象之间的引用关系看作一张图，通过一组名为”GC Root"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。

### 1.2 GC Root 对象

在 Java 中，有以下几种对象可以作为 GC Root：

1. Java 虚拟机栈（局部变量表）中的引用的对象。
2. 方法区中静态引用指向的对象。
3. 仍处于存活状态中的线程对象。
4. Native 方法中 JNI 引用的对象。

## 2 什么时候回收

不同的虚拟机实现有着不同的 GC 实现机制，但是一般情况下每一种 GC 实现都会在以下两种情况下触发垃圾回收。

1. Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC。

2. System.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。

## 3 如何回收垃圾

### 3.1 标记清除算法（Mark and Sweep GC）

### 3.2 复制算法（Copying）

### 3.3 标记-压缩算法 (Mark-Compact)

### 3.4 JVM分代回收策略

## 4 GC Log 分析

## 5 引用

## 6 总结
